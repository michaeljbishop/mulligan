{"name":"Mulligan","tagline":"Restartable Exceptions for Ruby (like Lisp's \"Conditions\" and \"Restarts\")","body":"[![Build Status](https://travis-ci.org/michaeljbishop/mulligan.png?branch=master)](https://travis-ci.org/michaeljbishop/mulligan)\r\n\r\n<img src=\"http://michaeljbishop.github.io/mulligan/images/mulligan-logo.png\" height=\"155\" width=\"440\" alt=\"Mulligan\">\r\n\r\n\"In golf, a mulligan is a stroke that is replayed from the spot of the previous stroke without penalty, due to an errant shot made on the previous stroke. The result is, as the hole is played and scored, as if the first errant shot had never been made.\" -- [Wikipedia](http://en.wikipedia.org/wiki/Mulligan_(games)#Mulligan_in_golf)\r\n\r\n## Usage\r\n\r\n### Two Stories\r\n\r\n#### The Spy Before Radios Were Invented\r\n\r\n> Once upon a time, there was a spy who had to infiltrate a 17 floor building, each new floor thick with guards. On the top floor was a safe to which he was given a combination. The safe would blow up if the wrong combination was used so he had to be careful. He successfully arrived at the safe after sneaking through all the floors and then he realized on his notes, the combination he was given was \"66-99-66\".\r\n>\r\n> To his dismay, he couldn't tell if he was reading it upside-down, and because radios hadn't yet been invented, Intelligence couldn't be contacted and not knowing what to do, he bailed on the mission by jumping out the window and was rescued on the ground by the allies. They told him he was holding the combination upside-down but now he'd have to again go through all 17 floors.\r\n\r\nThis the current state of Ruby exception handling. Once an exception is raised, you \"abort the mission\" and jump out the window where you are rescued. But then you have to start the mission again.\r\n\r\n#### The Spy After Radios Were Invented\r\n\r\nHere's the story again, but let's pretend radios now exist:\r\n\r\n> Once upon a time, there was a spy ... yada yada yada... It was then that he realized the combination he was given was 66-99-66.\r\n>\r\n> ***Because this mission now includes radios***, he was able to call intelligence, tell them what was happening and they told him he was holding the note upside-down. He then continued the mission by turning the note right-side-up and opening the safe.\r\n\r\nThe Mulligan gem adds to your exception handling, the radio from the second story. The Ruby `rescue` clause is like 'Intelligence' who receives the call (as an Exception instance). But attached to that Exception instance are 'recovery objects' which contain data about how to solve the problem. By invoking a recovery object, the code continues to exit without the mission aborting.\r\n\r\n### Code Example\r\n\r\nHere's a very simple contrived example:\r\n```ruby\r\n 1 require 'mulligan'\r\n 2 \r\n 3 def method_that_raises\r\n 4   puts \"RAISING\"\r\n 5   case recovery\r\n 6   when IgnoringRecovery\r\n 7     puts \"IGNORING\"\r\n 8   else\r\n 9     raise \"You can ignore this\"\r\n10   end\r\n11   puts \"AFTER RAISE\"\r\n12 end\r\n13\r\n14 def calling_method\r\n15   method_that_raises\r\n16   \"SUCCESS\"\r\n17 rescue Exception => e\r\n18   puts \"RESCUED\"\r\n19   recover IgnoringRecovery\r\n10   puts \"HANDLED\"\r\n21 end\r\n```\r\n\r\nRunning this at the REPL shows:\r\n\r\n```\r\n2.0.0-p353 :009 > calling_method\r\nRAISING\r\nRESCUED\r\nIGNORING\r\nAFTER RAISE\r\n => \"SUCCESS\" \r\n```\r\n\r\n### How come we didn't see \"HANDLED\" in that output?\r\n\r\nHere's what happened in detail:\r\n\r\n1. `#method_that_raises` is called from `#calling_method` (line 15)\r\n2. `#method_that_raises` raises an exception *but* before it is raised, a \"recovery\" can be added to the exception (line 6). That 'when' statement actually creates a an instance of `IgnoringRecovery`.\r\n3. The exception is then raised (line 9) and rescued (line 17)\r\n4. The \"recovery\" on the exception is called (line 19) which takes program execution back to line 7.\r\n5. Now, we are inside code that has succeeded the test in then `when` of line 6. Now it hits the `else` clause and skips the `#raise`\r\n6. The method exits (line 12) and we return to line 16 as if we never saw the exception.\r\n7. We exit the method because there's no exception to rescue (line 21). The last value in the function was \"SUCCESS\" so that is returned.\r\n\r\n### Use Cases\r\n\r\nThe truth is, often when we throw an exception in code, we probably could actually continue if we just knew what to do. Specifying recoveries allows you to suggest some options to the rescuing code.\r\n\r\nNot only that, you can apply a recovery strategy to large parts of code by handling exceptions at a high level and recovering from them.\r\n\r\nFrom the Dylan Language Manual:\r\n\r\n> A condition is an object used to locate and provide information to a handler. A condition represents a situation that needs to be handled. Examples are errors, warnings, and attempts to recover from errors.\r\n\r\n(\"condition\" is what we are calling \"exception\" in Ruby)\r\n\r\n#### Fixing network connection errors\r\n\r\n```ruby\r\ndef http_post(url, data)\r\n  ... networking code...\r\n  raise CredentialsExpiredException if response == 401\r\n  raise ConnectionFailedException if response == 404\r\nend\r\n\r\ndef post_resource(object)\r\n  ... assemble url and data...\r\n  http_post(url, data)\r\n  rescue Exception => e\r\n    case recovery\r\n    when RetryingRecovery\r\n      retry\r\n    else\r\n      raise e\r\n    end\r\nend\r\n\r\ndef save_resources\r\n  post_resource(user)\r\n  post_resource(post)\r\n  post_resource(comment)\r\n\r\n  rescue CredentialsExpiredException => e\r\n    ... fix credentials...\r\n    recover RetryingRecovery\r\n  rescue ConnectionFailedException => e\r\n    ... switch from wifi to cellular...\r\n    recover RetryingRecovery\r\nend\r\n```\r\n\r\n#### Screen Scraping (in Dylan)\r\n\r\n[I'm glad I used Dylan (comp.lang.dylan)](https://groups.google.com/d/msg/comp.lang.dylan/gszO7d7BAok/zqVbQlNDKzAJ)\r\n\r\nThis is going to be inherently messy and for a long-running program like this, potentially painful to restart if the data is found to be incorrect. Much better to just put in some recoveries and choose from them if errors are found.\r\n\r\n#### Handling errors in parsers\r\n\r\nYou might write a parser to read XML or a log file format and it might encounter malformed entries. You can make that low-level parser code much more reusable if you specify a few recoveries in the raised exceptions. Higher level code will have many more choices to handle errors.\r\n\r\n#### Ask your friendly Lisp coder. They've been solving these problems for years.\r\n\r\nYou've always known he (or she) knew Lisp and now you have something to ask him about.\r\n\r\n## Basic API\r\n### Kernel#recovery\r\n\r\n#### To Start A Case Statement\r\n\r\n`recovery` is used at the beginning of a `case` structure to indicate that each `when` clause is defining a `Recovery` instance to be attached to the next raised `Exception` instance.\r\n\r\nHere is the structure for using it:\r\n\r\n```ruby\r\ncase recovery\r\nwhen <recovery_class>           # or\r\n  ...code\r\nwhen <recovery_class>.new(...)  # or\r\n  ...code\r\nwhen <method_or_statement_that_returns_recovery_instance_or_class>\r\n  ...code\r\nelse\r\n  raise <exception>\r\nend\r\n```\r\n\r\nThe structure for this has to be quite strict. You *have* to put the raise inside the `else` and not before. (For more explanation, see the Appendix)\r\n\r\n#### To Retrieve a Recovery\r\n\r\nYou can also call `recovery(<recovery_class>)` when inside a rescue statement to see if there is a recovery attached to the exception that fits that class.\r\n\r\n```ruby\r\nrescue Exception => e\r\n  recover(IgnoringRecovery) unless recovery(IgnoringRecovery).nil?\r\n```\r\n\r\n### Kernel#recover\r\n\r\nInside a `rescue` clause, this invokes the recovery object. There is no return value from this. Code execution now proceeds back down into the stack to to the location in the case statement that matches the recovery class.\r\n\r\n```ruby\r\nrescue Exception => e\r\n  recover(IgnoringRecovery) unless recovery(IgnoringRecovery).nil?\r\n```\r\n\r\nAlso note that you can pass arguments which can be retrieved by the code implementing the `Recovery`.\r\n\r\n### Mulligan::Recovery\r\n\r\n`Mulligan::Recovery` is the base class of all recoveries. Use this in the same way you use the `Exception` hierarchy, but for recoveries. You can define your own subclasses with different properties that can be read by the `rescue` clauses.\r\n\r\n#### 'message' attribute\r\nThis is a human-readable description of what the `Recovery` does. It can be set at the time of raising, or if it's not set, will return `#default_message`\r\n\r\n#### #default_message\r\nIt's very important that you specify the `#default_message` method in your subclass. If your exception bubbles to the top-level within Pry, you can inspect the attached `Recovery` instances and execute them yourself. Without that `#default_message` method, you'll have no idea what a given Recovery will do.\r\n\r\n## Supported Rubies\r\n\r\n[![Build Status](https://travis-ci.org/michaeljbishop/mulligan.png?branch=master)](https://travis-ci.org/michaeljbishop/mulligan)\r\nMulligan fully supports MRI versions 1.9.3 -> 2.1.1\r\n\r\nMulligan will gracefully degrade to standard exception handling on other platforms. Though the API will be there, no recoveries will be attached to Exceptions.\r\n\r\n- If `Kernel#recover` is called in a Ruby that doesn't fully support Mulligan, it will be ignored and code execution will continue. This allows you to first try a recovery and after that, write the code that you would do before you had Mulligan.\r\n\r\n```ruby\r\nrescue TimeoutException => e\r\n  # retry the operation\r\n  recover(RetryingRecovery)\r\n  # if we get here, it's because there is no RetryingRecovery, or we don't have Mulligan\r\n  raise e\r\n```\r\n\r\n## FAQ\r\n\r\n### \"Recovery\"? What's wrong with \"Restart\"?\r\n\r\nI had to make a hard choice about naming the thing that allows an exception to be recovered from. \"Restart\" is the word used in Lisp, but because it is used as a verb and as a noun, it makes it hard to know what a Ruby method named `#restart` would do. Does it return a \"restart\" or does it execute a restart?\r\n\r\nChanging the name to a noun subtracts that confusion (though arguably adds some back for those coming from languages where the \"restart\" name is entrenched).\r\n\r\n### Will Mulligan let me resume from all exceptions?\r\n\r\nNo. If an exception didn't have recoveries attached when it was raised, you will not be able to call them. It is incumbent on the code that raises the exception to add the recoveries so they can control the error-handling flow.\r\n\r\n## Influences\r\n- [Beyond Exception Handling: Conditions and Restarts](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html) -- (from [Practical Common Lisp](http://www.gigamonkeys.com/book/))\r\n- [Things You Didn't Know About Exceptions](http://avdi.org/talks/rockymtnruby-2011/things-you-didnt-know-about-exceptions.html) (Avdi Grimm)\r\n- [Restartable Exceptions](http://chneukirchen.org/blog/archive/2005/03/restartable-exceptions.html) (Christian Neukirchen)\r\n- [Common Lisp conditions](https://www.ruby-forum.com/topic/179474) (Ruby Forum)\r\n\r\n### Acknowledgements\r\nThanks to [Ryan Angilly](https://twitter.com/angilly) of [Ramen](https://ramen.is) who graciously released the gem name 'mulligan' to be used with this project. If you've got a good software project, consider launching with them.\r\n\r\n## Further Reading\r\n- [Dylan Reference Manual - Conditions - Background](http://opendylan.org/books/drm/Conditions_Background)\r\n\r\n## Appendix\r\n\r\nI had to pull off some tricks to achieve the `case` structure in Mulligan. If I had more control over the Ruby Language, my preferred syntax for specifying recoveries would be:\r\n\r\n```ruby\r\nraise [Exception [, message [, backtrace]]]\r\n  # ... code that is always executed during a recovery\r\nrecovery <Recover class>\r\n  # ... recovery code\r\nrecovery <Recover class> => args\r\n  # ... recovery code that uses the args passed back\r\nend\r\n```\r\n\r\n\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'mulligan'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install mulligan\r\n\r\n## Contributing\r\n\r\n1. Fork it [http://github.com/michaeljbishop/mulligan](http://github.com/michaeljbishop/mulligan)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n\r\n## Homepage\r\n\r\n[http://michaeljbishop.github.io/mulligan/](http://michaeljbishop.github.io/mulligan/)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}