{"name":"Mulligan","tagline":"Restartable Exceptions for Ruby (like Lisp's \"Conditions\" and \"Restarts\")","body":"[![Build Status](https://travis-ci.org/michaeljbishop/mulligan.png?branch=master)](https://travis-ci.org/michaeljbishop/mulligan)\r\n# Mulligan\r\n\r\n\"In golf,...a stroke that is replayed from the spot of the previous stroke without penalty, due to an errant shot made on the previous stroke. The result is, as the hole is played and scored, as if the first errant shot had never been made.\" -- [Wikipedia](http://en.wikipedia.org/wiki/Mulligan_(games)#Mulligan_in_golf)\r\n\r\n## Usage\r\n\r\nWhen rescuing an exception, the Mulligan gem allows you to execute some recovery code, then continue your program as if the exception had never been thrown in the first place\r\n\r\nHere's a very simple contrived example:\r\n```ruby\r\n 1 require 'mulligan'\r\n 2 \r\n 3 def method_that_raises\r\n 4   puts \"RAISING\"\r\n 5   raise \"You can ignore this\" do |e|\r\n 6     e.set_recovery :ignore do\r\n 7       puts \"IGNORING\"\r\n 8     end\r\n 9   end\r\n10   puts \"AFTER RAISE\"\r\n11 end\r\n12\r\n13 def calling_method\r\n14   method_that_raises\r\n15   \"SUCCESS\"\r\n16   rescue Exception => e\r\n17     puts \"RESCUED\"\r\n18     e.recover :ignore\r\n19     puts \"HANDLED\"\r\n20 end\r\n```\r\n\r\nRunning this at the REPL shows:\r\n\r\n```\r\n2.0.0-p353 :009 > calling_method\r\nRAISING\r\nRESCUED\r\nIGNORING\r\nAFTER RAISE\r\n => \"SUCCESS\" \r\n```\r\n\r\n### Yeah... wait, shouldn't we see \"HANDLED\" in that output?!\r\n\r\nHere's what happened in detail:\r\n\r\n1. `#method_that_raises` is called from `#calling_method` (line 14)\r\n2. `#method_that_raises` raises an exception *but* before it is raised, a \"recovery\" can be added to the exception (line 6) in the block passed to `#raise`. (The exception is the parameter 'e' passed to the `#raise` block)\r\n3. The exception is then raised (line 5) and rescued (line 16)\r\n4. The \"recovery\" on the exception is called (line 18) which executes the statement in the recovery block (defined on line 7).\r\n5. Since the exception has recovered, control taks us back to the point *immediately after the block passed to* `#raise` (line 10), continuing as if `#raise` hadn't been called in the first place.\r\n6. The method exits (line 11) and we return to line 15 as if we never saw the exception.\r\n7. We exit the method because there's no exception to rescue (line 20). The last value in the function was \"SUCCESS\" so that is returned.\r\n\r\n### I see what you did there. That's cool, but why should I care?\r\n\r\nYou should care because your `rescue` statement is likely to be far from the `raise` in your program's execution and the further away it is, the harder it is to fix the error intelligently. It's even harder if that `raise` comes from a library you are calling.\r\n\r\nSpecifying recoveries on the exception allows the lower-level code to offer strategies for fixing the exception without the higher-level code needing to know the internals of those strategies.\r\n\r\nBetter yet, it offers the ability to \"go back in time\" [Groundhog Day](http://en.wikipedia.org/wiki/Groundhog_Day_(film))-style, but this time, your code knows how to play the piano, how to sculpt ice, and how to speak French.\r\n\r\nFind your favorite chair and read these:\r\n\r\n- [Dylan Reference Manual - Conditions - Background](http://opendylan.org/books/drm/Conditions_Background)\r\n- [Beyond Exception Handling: Conditions and Restarts](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html) (keep in mind the \"restarts\" are what we are calling \"recoveries\").\r\n\r\n### This *seems* like a good thing, but what can I do with it?\r\n\r\nHere are some use cases:\r\n\r\n#### Fixing network connection errors\r\n\r\n```ruby\r\ndef http_post(url, data)\r\n  ... networking code...\r\n  raise CredentialsExpiredException if response == 401\r\n  raise ConnectionFailedException if response == 404\r\nend\r\n\r\ndef post_resource(object)\r\n  ... assemble url and data...\r\n  http_post(url, data)\r\n  rescue Exception => e\r\n    raise(e){|e|e.set_recovery(:retry){}}\r\n    retry if last_recovery == :retry\r\nend\r\n\r\ndef save_resources\r\n  post_resource(user)\r\n  post_resource(post)\r\n  post_resource(comment)\r\n\r\n  rescue CredentialsExpiredException => e\r\n    ... fix credentials...\r\n    e.recover :retry\r\n  rescue ConnectionFailedException => e\r\n    ... switch from wifi to cellular...\r\n    e.recover :retry\r\nend\r\n```\r\n\r\n#### Screen Scraping (in Dylan)\r\n\r\n[The maling list post](https://groups.google.com/d/msg/comp.lang.dylan/gszO7d7BAok/zqVbQlNDKzAJ)\r\n\r\nThis is going to be inherently messy and for a long-running program like this, potentially painful to restart if the data is found to be incorrect. Much better to just put in some recoveries and choose from them if errors are found.\r\n\r\n#### Handling errors in parsers\r\n\r\nYou might write a parser to read XML or a log file format and it might encounter malformed entries. You can make that low-level parser code much more reusable if you specify a few recoveries in the raised exceptions. Higher level code will have many more choices to handle errors.\r\n\r\nBTW, Here's your second chance to read [Beyond Exception Handling: Conditions and Restarts](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html). There's a log file parsing example in there.\r\n\r\n#### Ask your friendly Lisp coder. They've been solving these problems for years.\r\n\r\nYou've always known he (or she) knew Lisp and now you have something to ask him about.\r\n\r\n## Some Notes About the Ruby Implementation\r\n### Methods\r\n#### Kernel#raise\r\n1. `Kernel#raise` now has a return value! It is the value returned from the recovery block.\r\n2. `Kernel#raise` also yields the exception to a block. It does this since it's pretty common to have `Kernel#raise` create an exception for you and without this, you couldn't otherwise attach recoveries.\r\n\r\n```ruby\r\ndef test\r\n  # (result is explicit for this example)\r\n  result = raise \"Test\" do |e|              # yields Exception to the block\r\n    e.set_recovery(:test_return){\"hello\"}   # recovery block returns a string\r\n  end\r\n  result\r\nrescue Exception => e\r\n  e.recover :test_return\r\nend\r\n```\r\n\r\nreturns \r\n\r\n```\r\n2.0.0-p353 :012 > test\r\n => \"hello\" \r\n```\r\n\r\n#### You can pass parameters to Exception#recover\r\nThe first parameter is always the id of the recovery. The rest will be passed directly to the recovery block. Building on the above example:\r\n\r\n```ruby\r\ndef test\r\n  # (result is explicit for this example)\r\n  result = raise \"Test\" do |e|\r\n    e.set_recovery(:test_return){|p|p} # pass back whatever is passed in\r\n  end\r\n  result\r\nrescue Exception => e\r\n  e.recover :test_return, 5\r\nend\r\n```\r\n\r\nreturns \r\n\r\n```\r\n2.0.0-p353 :012 > test\r\n => 5\r\n```\r\n\r\n#### Your recovery can attach data to be read by the rescue clause\r\nYou can pass an options hash to the `rescue` clause that is attached to your recovery. This is handy if you want to attach extra data about the recovery or the circumstances in which it is being raised. Pass them as the second parameter in `Exception#set_recovery`. You can retrieve them with `Exception#recovery_options`. Reserved keys are `:summary`, and `:discussion`\r\n```ruby\r\nraise \"Test\" do |e|\r\n  summary = \"Replaces the misparsed entry with one you specify.\"\r\n  e.set_recovery(:replace_value, :summary => summary){|p|p}\r\nend\r\n```\r\n\r\nTo demonstrate this, here's a rescue statement. The rescue simply prints out the description which is not really useful as a rescue statement, but it's an example of how a REPL might output to the user a list of recoveries to choose from and the details of what they do.\r\n\r\n```ruby\r\nrescue MisparsedEntryException => e\r\n  $stderr.puts \"Choose a recovery:\"\r\n  e.recovery_identifiers.each do |id|\r\n    $stderr.puts \"  #{id}: - #{e.recovery_options(id)[:summary]}\"\r\n  end\r\n  ... read choice and execute ...\r\n```\r\n\r\n#### Kernel#last_recovery\r\nThere is a new method: `Kernel#last_recovery` which will return the id of the last recovery invoked for the current thread. So you can do things like this:\r\n\r\n```ruby\r\nbegin\r\n  ... some code ...\r\nrescue Exception => e\r\n  raise(e){|e|e.set_recovery(:retry){}}\r\n  retry if last_recovery == :retry\r\nend\r\n```\r\n\r\n### Mulliigan uses #callcc\r\n\r\nThere is more than one way to do this. In the end, I wanted something that would fit very naturally into Ruby's existing Exception mechanism, yet offer as much of the benefits of Lisp's \"restart\" as I could.\r\n\r\nHowever, to make that happen, I had to use the `#callcc` method. I'm not completely sure how supported this is across different Ruby implementations. Additionally, I've read that it can be a rather slow method. It's important to note that if an exception is raised but does not have any attached recoveries, `#callcc` will not be called and the standard exception mechanism is used.\r\n\r\n### Ruby Support\r\n\r\n[![Build Status](https://travis-ci.org/michaeljbishop/mulligan.png?branch=master)](https://travis-ci.org/michaeljbishop/mulligan)\r\n Mulligan supports MRI versions 1.9.3 -> 2.1.1\r\n\r\n### \"Recovery\"? What's wrong with \"Restart\"?\r\n\r\nI had to make a hard choice about naming the thing that allows an exception to be recovered from. \"Restart\" is the word used in Lisp, but because it is used as a verb and as a noun, it makes it hard to know what a Ruby method named `#restart` would do. Does it return a \"restart\" or does it execute a restart?\r\n\r\nChanging the name to a noun subtracts that confusion (though arguably adds some back for those coming from languages where the \"restart\" name is entrenched).\r\n\r\n## Influences\r\n- [Beyond Exception Handling: Conditions and Restarts](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html) -- (from [Practical Common Lisp](http://www.gigamonkeys.com/book/))\r\n- [Things You Didn't Know About Exceptions](http://avdi.org/talks/rockymtnruby-2011/things-you-didnt-know-about-exceptions.html) (Avdi Grimm)\r\n- [Restartable Exceptions](http://chneukirchen.org/blog/archive/2005/03/restartable-exceptions.html) (Christian Neukirchen)\r\n- [Common Lisp conditions](https://www.ruby-forum.com/topic/179474) (Ruby Forum)\r\n\r\n## Installation\r\n\r\nAt the moment, 'mulligan' isn't submitted to RubyGems. However, you can still include it as a gem by adding this line to your application's Gemfile:\r\n\r\n    gem \"mulligan\", github: 'michaeljbishop/mulligan'\r\n\r\nThen execute:\r\n\r\n    $ bundle\r\n\r\n## Contributing\r\n\r\n1. Fork it [http://github.com/michaeljbishop/mulligan](http://github.com/michaeljbishop/mulligan)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}